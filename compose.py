"""
Generate random composite knots by sampling from knot tables.
"""
from sys import argv, stdout
from regina import *
from sample import sample, extractFilenames
from decomposeknot import decompose, DecompositionTracker


def generateComposites( numKnots, numSummands, *datasets ):
    """
    Generates the given number of knots, each given by composing the given
    number of summands, by randomly sampling summands from the given
    datasets.

    Each summand is generated by selecting one of the datasets uniformly at
    random, and then choosing one of the knots in the selected dataset
    uniformly at random.

    Each given dataset should be the name of a text file containing a list of
    filenames. Each listed filename should be a CSV file in the same
    directory as the corresponding dataset file, and each such CSV file
    should include (at least) the following data:
    --> a column of knot names under the heading "name"; and
    --> a column of knot signatures under the heading "knot_sig".
    """
    numSets = len(datasets)
    if numSets == 1:
        sampleSizes = [ numKnots * numSummands ]
        summandSources = [ [0]*numSummands for _ in range(numKnots) ]
    else:
        RandomEngine.reseedWithHardware()

        # Which dataset should we get each summand from?
        sampleSizes = [0]*numSets
        summandSources = []
        for _ in range(numKnots):
            temp = []
            for _ in range(numSummands):
                # Randomly pick one of the datasets from which to generate
                # one of the summands.
                setNumber = RandomEngine.rand(numSets)
                sampleSizes[setNumber] += 1
                temp.append(setNumber)
            summandSources.append(temp)

    # Randomly sample summands from each dataset.
    knotNamesAndSigs = []
    for setNumber in range(numSets):
        summandSample = sample( sampleSizes[setNumber],
                *extractFilenames( datasets[setNumber] ) )
        knotNamesAndSigs.append(summandSample)

        # Use Fisher-Yates to shuffle the sample (in-place).
        for i in range( sampleSizes[setNumber] - 1, 0, -1 ):
            swapi = RandomEngine.rand(i+1)
            summandSample[i], summandSample[swapi] = (
                    summandSample[swapi], summandSample[i] )

    # Use sampled summands to generate a list of composite knots.
    composites = []
    for sources in summandSources:
        summandNames = []
        summandSigs = []
        for setNumber in sources:
            name, sig = knotNamesAndSigs[setNumber].pop()
            summandNames.append(name)
            summandSigs.append(sig)

        # Build the composite knot.
        compositeName = summandNames[0]
        compositeKnot = Link.fromKnotSig( summandSigs[0] )
        for i in range( 1, numSummands ):
            compositeName += " # {}".format( summandNames[i] )
            compositeKnot.composeWith(
                    Link.fromKnotSig( summandSigs[i] ) )
        composites.append( ( compositeName, compositeKnot ) )
    return composites


def decomposeComposites( numKnots, numSummands, *datasets ):
    """
    Generates the given number of knots, each given by composing the given
    number of summands, and then decomposes all the generated knots.

    The summands are sampled using the generateComposites() routine, so the
    format of the given datasets must adhere to the specifications stated in
    the documentation for generateComposites().

    This routine prints the results of each decomposition to standard output.
    """
    title = "Knots given by composing {} summands".format(numSummands)
    print()
    print( "+-" + "-"*len(title) + "-+" )
    print( "| {} |".format(title) )
    print( "+-" + "-"*len(title) + "-+" )
    print()
    print( "Sampling summands from the following data sets:" )
    for dataset in datasets:
        filenames = extractFilenames(dataset)
        strings = []
        for filename in filenames:
            strings.append(
                    filename.split( "/" )[-1].split( "." )[0] )
        print( "    {}".format( ", ".join(strings) ) )
    print()
    stdout.flush()
    timedOutCases = []
    data = []
    totalTime = 0
    knots = generateComposites( numKnots, numSummands, *datasets )
    for name, knot in knots:
        print(name)
        print( "-"*len(name) )

        # Scale timeout time with the number of crossings.
        tracker = DecompositionTracker( True, 2*knot.size() )
        try:
            primes = decompose( knot, tracker )
        except TimeoutError as timeout:
            timedOutCases.append(name)
            print(timeout)
            print()
            continue
        if len(primes) == 0:
            print( "Unknot!" )
        elif len(primes) == 1:
            print( "Found 1 prime:" )
        else:
            print( "Found {} primes:".format( len(primes) ) )
        for i, loop in enumerate(primes):
            print( "    Drilled iso sig for prime #{}: {}".format(
                i, loop.drill().isoSig() ) )

        # Store data for post-processing.
        data.append( ( name, tracker.elapsed() ) )
        totalTime += tracker.elapsed()
        print()
    print( "="*32 )
    print( "Total knots: {}.".format(numKnots) )
    print( "Total time: {:.6f}.".format(totalTime) )
    if timedOutCases:
        print( "Cases that timed out ({} in total):".format(
            len(timedOutCases) ) )
        for name in timedOutCases:
            print( "    Name: {}.".format(name) )
    completedCount = numKnots - len(timedOutCases)
    if completedCount:
        slowCoefficient = 2
        average = totalTime / completedCount
        print( "Cases slower than {} times the average:".format(
            slowCoefficient ) )
        noSlowCases = True
        for name, time in data:
            if time > slowCoefficient * average:
                noSlowCases = False
                print( "    Name: {}. Time: {:.6f}.".format( name, time ) )
        if noSlowCases:
            print( "    (None)" )
    print()
    return


if __name__ == "__main__":
    numKnots = int( argv[1] )
    numSummands = int( argv[2] )
    decomposeComposites( numKnots, numSummands, *argv[3:] )
